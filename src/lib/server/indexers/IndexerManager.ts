/**
 * IndexerManager - Central service for managing indexers.
 * YAML-only architecture: all indexers (torrent, usenet, streaming)
 * are defined by YAML files loaded from data/indexers/definitions.
 * Handles definition loading, indexer creation, and search orchestration.
 */

import { db } from '$lib/server/db';
import {
	indexers as indexersTable,
	type TorrentProtocolSettings,
	type UsenetProtocolSettings,
	type StreamingProtocolSettings
} from '$lib/server/db/schema';
import { eq } from 'drizzle-orm';
import { randomUUID } from 'node:crypto';
import { logger } from '$lib/logging';

import type {
	IIndexer,
	IndexerConfig,
	SearchCriteria,
	SearchResult,
	IndexerCapabilities,
	SearchParam,
	SearchMode
} from './types';
import { YamlDefinitionLoader, YamlIndexerFactory } from './loader';
import type { YamlDefinition } from './schema/yamlDefinition';
import { resolveCategoryId } from './schema/yamlDefinition';
import {
	getSearchOrchestrator,
	type SearchOrchestratorOptions,
	type EnhancedSearchResult
} from './search/SearchOrchestrator';
import { getPersistentStatusTracker } from './status';
import { getRateLimitRegistry } from './ratelimit';
import { cleanupIndexerCookies } from './http/IndexerHttp';
import { CINEPHAGE_STREAM_DEFINITION_ID } from './types';

/** Manager options */
export interface IndexerManagerOptions {
	/** Path(s) to YAML definitions directory */
	definitionsPath?: string | string[];
}

/**
 * Central service for managing indexers.
 */
export class IndexerManager {
	private definitionLoader: YamlDefinitionLoader;
	private indexerFactory: YamlIndexerFactory;
	private indexerInstances: Map<string, IIndexer> = new Map();

	constructor(options: IndexerManagerOptions = {}) {
		const path = options.definitionsPath;
		const definitionsPath = typeof path === 'string' ? path : path?.[0];
		this.definitionLoader = new YamlDefinitionLoader(definitionsPath);
		this.indexerFactory = new YamlIndexerFactory(this.definitionLoader);
	}

	/** Initialize the manager - load definitions */
	async initialize(): Promise<void> {
		logger.info('Initializing IndexerManager');
		await this.definitionLoader.loadAll();

		// Seed built-in streaming indexer if not exists
		await this.seedStreamingIndexer();

		logger.info('IndexerManager initialized', {
			definitionCount: this.definitionLoader.count,
			errors: this.definitionLoader.getErrors().length
		});

		// Log any errors
		for (const error of this.definitionLoader.getErrors()) {
			logger.warn('Definition load error', {
				file: error.filePath,
				error: error.error
			});
		}
	}

	/** Get all available YAML definitions */
	getDefinitions(): YamlDefinition[] {
		return this.definitionLoader.getAll();
	}

	/** Get all definitions converted to unified format for UI */
	getUnifiedDefinitions(): import('./loader').IndexerDefinition[] {
		return this.definitionLoader.getAllUnified();
	}

	/** Get a unified definition by ID */
	getUnifiedDefinition(id: string): import('./loader').IndexerDefinition | undefined {
		return this.definitionLoader.getUnified(id);
	}

	/** Get definition loading errors */
	getDefinitionErrors(): Array<{ filePath: string; error: string }> {
		return this.definitionLoader.getErrors();
	}

	/** Check if definitions have been loaded */
	isDefinitionsLoaded(): boolean {
		return this.definitionLoader.isLoaded();
	}

	/** Get a specific definition by ID (YAML-only) */
	getDefinition(id: string): YamlDefinition | undefined {
		return this.definitionLoader.get(id);
	}

	/** Check if a definition exists (YAML-only) */
	hasDefinition(id: string): boolean {
		return this.definitionLoader.hasDefinition(id);
	}

	/** Reload all definitions */
	async reloadDefinitions(): Promise<void> {
		await this.definitionLoader.reload();

		// Recreate factory with new loader state
		this.indexerFactory = new YamlIndexerFactory(this.definitionLoader);

		// Clear cached indexer instances so they get recreated
		this.indexerInstances.clear();
	}

	/**
	 * Seed the built-in streaming indexer if it doesn't exist in the database.
	 * This ensures users can use the streaming indexer without manual setup.
	 */
	private async seedStreamingIndexer(): Promise<void> {
		// Check if streaming indexer already exists
		const existing = await db
			.select()
			.from(indexersTable)
			.where(eq(indexersTable.definitionId, CINEPHAGE_STREAM_DEFINITION_ID));

		if (existing.length > 0) {
			logger.debug('Streaming indexer already exists in database');
			return;
		}

		// Get definition info from YAML loader
		const def = this.definitionLoader.get(CINEPHAGE_STREAM_DEFINITION_ID);
		if (!def) {
			logger.warn('Streaming indexer definition not found', { id: CINEPHAGE_STREAM_DEFINITION_ID });
			return;
		}

		// Create the streaming indexer (ID auto-generated by $defaultFn)
		await db.insert(indexersTable).values({
			name: def.name,
			definitionId: CINEPHAGE_STREAM_DEFINITION_ID,
			enabled: true, // Enabled by default
			baseUrl: def.links[0] || 'http://localhost',
			priority: 50, // Lower priority than torrent indexers (higher number = lower priority)
			enableAutomaticSearch: true, // Include in automatic searches
			enableInteractiveSearch: true // Include in manual searches
		});

		logger.info('Seeded built-in streaming indexer to database', {
			definitionId: CINEPHAGE_STREAM_DEFINITION_ID,
			name: def.name
		});
	}

	/** Get all configured indexers from database */
	async getIndexers(): Promise<IndexerConfig[]> {
		const rows = await db.select().from(indexersTable);
		return rows.map((row) => this.rowToConfig(row));
	}

	/** Get a specific indexer config by ID */
	async getIndexer(id: string): Promise<IndexerConfig | undefined> {
		const rows = await db.select().from(indexersTable).where(eq(indexersTable.id, id));
		return rows[0] ? this.rowToConfig(rows[0]) : undefined;
	}

	/** Create a new indexer configuration */
	async createIndexer(config: Omit<IndexerConfig, 'id' | 'protocol'>): Promise<IndexerConfig> {
		// YAML-only architecture - all definitions come from YAML
		const yamlDef = this.definitionLoader.get(config.definitionId);

		if (!yamlDef) {
			throw new Error(`Unknown definition: ${config.definitionId}`);
		}

		// Get default URL from YAML definition
		const defaultUrl = yamlDef.links[0];

		// Build protocol settings from config
		const protocolSettings = this.buildProtocolSettings(config, yamlDef.protocol);

		// Insert and return the generated ID
		const result = await db
			.insert(indexersTable)
			.values({
				name: config.name,
				definitionId: config.definitionId,
				enabled: config.enabled,
				baseUrl: config.baseUrl ?? defaultUrl,
				alternateUrls: config.alternateUrls ?? null,
				priority: config.priority,
				settings: config.settings as Record<string, string | number | boolean>,
				protocolSettings: protocolSettings ?? undefined,

				// Search capability toggles
				enableAutomaticSearch: config.enableAutomaticSearch,
				enableInteractiveSearch: config.enableInteractiveSearch
			})
			.returning({ id: indexersTable.id });

		const id = result[0]?.id;
		if (!id) {
			throw new Error('Failed to create indexer: no ID returned');
		}

		const created = await this.getIndexer(id);
		if (!created) {
			throw new Error('Failed to create indexer');
		}

		return created;
	}

	/** Build protocol-specific settings from config */
	private buildProtocolSettings(
		config: Partial<IndexerConfig>,
		protocol: string
	): TorrentProtocolSettings | UsenetProtocolSettings | StreamingProtocolSettings | null {
		if (protocol === 'torrent') {
			return {
				minimumSeeders: config.minimumSeeders ?? 1,
				seedRatio: config.seedRatio ?? null,
				seedTime: config.seedTime ?? null,
				packSeedTime: config.packSeedTime ?? null,
				rejectDeadTorrents: config.rejectDeadTorrents ?? true
			};
		}
		if (protocol === 'usenet') {
			return {
				minimumRetention: null,
				maximumRetention: null,
				downloadPriority: 'normal',
				preferCompleteNzb: true,
				rejectPasswordProtected: true
			};
		}
		if (protocol === 'streaming') {
			return {
				baseUrl: null,
				preferredQuality: 'auto',
				includeInAutoSearch: true,
				enabledProviders: null,
				blockedProviders: null
			};
		}
		return null;
	}

	/** Update an indexer configuration */
	async updateIndexer(
		id: string,
		updates: Partial<Omit<IndexerConfig, 'id' | 'definitionId'>>
	): Promise<IndexerConfig> {
		const existing = await this.getIndexer(id);
		if (!existing) {
			throw new Error(`Indexer not found: ${id}`);
		}

		const updateData: Record<string, unknown> = {};
		if (updates.name !== undefined) updateData.name = updates.name;
		if (updates.enabled !== undefined) updateData.enabled = updates.enabled ? 1 : 0;
		if (updates.baseUrl !== undefined) updateData.baseUrl = updates.baseUrl;
		if (updates.alternateUrls !== undefined) updateData.alternateUrls = updates.alternateUrls;
		if (updates.priority !== undefined) updateData.priority = updates.priority;
		if (updates.settings !== undefined) updateData.settings = updates.settings;

		// Search capability toggles
		if (updates.enableAutomaticSearch !== undefined)
			updateData.enableAutomaticSearch = updates.enableAutomaticSearch;
		if (updates.enableInteractiveSearch !== undefined)
			updateData.enableInteractiveSearch = updates.enableInteractiveSearch;

		// Update protocol settings if any torrent-specific fields are changed
		if (
			updates.minimumSeeders !== undefined ||
			updates.seedRatio !== undefined ||
			updates.seedTime !== undefined ||
			updates.packSeedTime !== undefined ||
			updates.rejectDeadTorrents !== undefined
		) {
			const currentSettings =
				(existing as IndexerConfig & { protocolSettings?: Record<string, unknown> })
					.protocolSettings ?? {};
			updateData.protocolSettings = {
				...currentSettings,
				...(updates.minimumSeeders !== undefined && { minimumSeeders: updates.minimumSeeders }),
				...(updates.seedRatio !== undefined && { seedRatio: updates.seedRatio }),
				...(updates.seedTime !== undefined && { seedTime: updates.seedTime }),
				...(updates.packSeedTime !== undefined && { packSeedTime: updates.packSeedTime }),
				...(updates.rejectDeadTorrents !== undefined && {
					rejectDeadTorrents: updates.rejectDeadTorrents
				})
			};
		}

		await db.update(indexersTable).set(updateData).where(eq(indexersTable.id, id));

		// Clear cached instances so they get recreated with new settings
		this.indexerInstances.delete(id);
		this.indexerFactory.removeIndexer(id);

		// Update status tracking
		const statusTracker = getPersistentStatusTracker();
		if (updates.enabled !== undefined) {
			if (updates.enabled) {
				statusTracker.enable(id);
			} else {
				statusTracker.disable(id);
			}
		}
		if (updates.priority !== undefined) {
			statusTracker.setPriority(id, updates.priority);
		}

		const updated = await this.getIndexer(id);
		if (!updated) {
			throw new Error('Failed to update indexer');
		}

		return updated;
	}

	/** Delete an indexer */
	async deleteIndexer(id: string): Promise<void> {
		await db.delete(indexersTable).where(eq(indexersTable.id, id));

		// Clean up all resources
		this.indexerInstances.delete(id);
		this.indexerFactory.removeIndexer(id);
		getPersistentStatusTracker().remove(id);
		getRateLimitRegistry().remove(id);
		cleanupIndexerCookies(id); // Clean up cookie jar to prevent memory leak
	}

	/** Create an indexer instance from config (YAML-only architecture) */
	private async createIndexerInstance(config: IndexerConfig): Promise<IIndexer | null> {
		const instance = await this.indexerFactory.createIndexer(config);
		if (instance) {
			logger.debug('Created indexer instance', {
				indexerId: config.id,
				definitionId: config.definitionId,
				protocol: config.protocol
			});
		}
		return instance;
	}

	/** Get or create an indexer instance */
	async getIndexerInstance(id: string): Promise<IIndexer | undefined> {
		// Check cache first
		let instance = this.indexerInstances.get(id);
		if (instance) return instance;

		// Load config
		const config = await this.getIndexer(id);
		if (!config) return undefined;

		// Create instance
		try {
			instance = (await this.createIndexerInstance(config)) ?? undefined;
			if (instance) {
				this.indexerInstances.set(id, instance);
			}
			return instance;
		} catch (error) {
			logger.error('Failed to create indexer instance', error, { indexerId: id });
			return undefined;
		}
	}

	/** Get all enabled indexer instances with batch optimization */
	async getEnabledIndexers(): Promise<IIndexer[]> {
		const configs = await this.getIndexers();
		const enabledConfigs = configs.filter((c) => c.enabled);

		// Separate cached from uncached for batch processing
		const cached: IIndexer[] = [];
		const needsCreation: IndexerConfig[] = [];

		for (const config of enabledConfigs) {
			const existing = this.indexerInstances.get(config.id);
			if (existing) {
				cached.push(existing);
			} else {
				needsCreation.push(config);
			}
		}

		// Create uncached instances (async to allow capability fetching)
		const created: IIndexer[] = [];
		for (const config of needsCreation) {
			try {
				const instance = await this.createIndexerInstance(config);
				if (instance) {
					this.indexerInstances.set(config.id, instance);
					created.push(instance);
				}
			} catch (error) {
				logger.error('Failed to create indexer instance', error, { indexerId: config.id });
			}
		}

		logger.debug('getEnabledIndexers batch result', {
			total: enabledConfigs.length,
			cached: cached.length,
			newlyCreated: created.length
		});

		return [...cached, ...created];
	}

	/** Search across all enabled indexers */
	async search(
		criteria: SearchCriteria,
		options?: SearchOrchestratorOptions
	): Promise<SearchResult> {
		const indexers = await this.getEnabledIndexers();
		const orchestrator = getSearchOrchestrator();
		return orchestrator.search(indexers, criteria, options);
	}

	/**
	 * Enhanced search with quality filtering and optional TMDB matching.
	 * Returns enriched releases with parsed metadata and quality scores.
	 */
	async searchEnhanced(
		criteria: SearchCriteria,
		options?: SearchOrchestratorOptions
	): Promise<EnhancedSearchResult> {
		const indexers = await this.getEnabledIndexers();
		const orchestrator = getSearchOrchestrator();
		return orchestrator.searchEnhanced(indexers, criteria, options);
	}

	/** Test an indexer's connectivity (YAML-only) */
	async testIndexer(config: Omit<IndexerConfig, 'id'>): Promise<void> {
		const definition = this.definitionLoader.get(config.definitionId);
		if (!definition) {
			throw new Error(`Unknown definition: ${config.definitionId}`);
		}

		const tempConfig: IndexerConfig = {
			...config,
			id: 'test-' + randomUUID()
		};

		const instance = await this.createIndexerInstance(tempConfig);
		if (!instance) {
			throw new Error(`Failed to create indexer instance for: ${config.definitionId}`);
		}
		await instance.test();
	}

	/** Get capabilities for a definition (YAML-only) */
	getDefinitionCapabilities(definitionId: string): IndexerCapabilities | undefined {
		const definition = this.definitionLoader.get(definitionId);
		if (!definition) return undefined;

		return this.buildCapabilities(definition);
	}

	/** Get required settings fields for a definition (YAML-only) */
	getDefinitionSettings(
		definitionId: string
	): Array<{ name: string; type: string; label: string; default?: string }> {
		return this.indexerFactory.getRequiredSettings(definitionId);
	}

	/** Get all available definitions with metadata (YAML-only) */
	getAvailableDefinitions(): Array<{
		id: string;
		name: string;
		type: string;
		language: string;
		description?: string;
		protocol?: string;
	}> {
		return this.indexerFactory.getAllDefinitionMetadata();
	}

	/** Search definitions by name */
	searchDefinitions(query: string): YamlDefinition[] {
		return this.definitionLoader.searchByName(query);
	}

	/** Get definitions by type */
	getDefinitionsByType(type: 'public' | 'private' | 'semi-private'): YamlDefinition[] {
		return this.definitionLoader.getByType(type);
	}

	/** Convert database row to IndexerConfig */
	private rowToConfig(row: typeof indexersTable.$inferSelect): IndexerConfig {
		// Get protocol from YAML definition
		const definition = this.definitionLoader.get(row.definitionId);
		const protocol = definition?.protocol ?? 'torrent';

		// Extract torrent-specific settings from protocolSettings JSON
		const protocolSettings = row.protocolSettings as {
			minimumSeeders?: number;
			seedRatio?: string | null; // Stored as string (e.g., "1.5")
			seedTime?: number | null;
			packSeedTime?: number | null;
			rejectDeadTorrents?: boolean;
		} | null;

		return {
			id: row.id,
			name: row.name,
			definitionId: row.definitionId,
			enabled: !!row.enabled,
			baseUrl: row.baseUrl,
			alternateUrls: row.alternateUrls ?? [],
			priority: row.priority ?? 25,
			protocol,
			settings: (row.settings as Record<string, string>) ?? {},

			// Search capability toggles
			enableAutomaticSearch: row.enableAutomaticSearch ?? true,
			enableInteractiveSearch: row.enableInteractiveSearch ?? true,

			// Torrent seeding settings (from protocolSettings JSON)
			minimumSeeders: protocolSettings?.minimumSeeders ?? 1,
			seedRatio: protocolSettings?.seedRatio ?? null,
			seedTime: protocolSettings?.seedTime ?? null,
			packSeedTime: protocolSettings?.packSeedTime ?? null,
			rejectDeadTorrents: protocolSettings?.rejectDeadTorrents ?? true
		};
	}

	/** Build capabilities from YAML definition */
	private buildCapabilities(definition: YamlDefinition): IndexerCapabilities {
		const caps = definition.caps;
		const modes = caps.modes ?? {};

		// Helper to convert param strings to SearchParam type
		const toSearchParams = (params: string[] | undefined): SearchParam[] => {
			if (!params) return ['q'];
			const mapping: Record<string, SearchParam> = {
				q: 'q',
				imdbid: 'imdbId',
				tmdbid: 'tmdbId',
				tvdbid: 'tvdbId',
				tvmazeid: 'tvMazeId',
				traktid: 'traktId',
				season: 'season',
				ep: 'ep',
				year: 'year',
				genre: 'genre',
				artist: 'artist',
				album: 'album',
				author: 'author',
				title: 'title'
			};
			return params.map((p) => mapping[p.toLowerCase()] ?? ('q' as SearchParam));
		};

		// Helper to build SearchMode
		const buildSearchMode = (params: string[] | undefined): SearchMode => ({
			available: params !== undefined && params.length > 0,
			supportedParams: toSearchParams(params)
		});

		// Build category map
		const categories = new Map<number, string>();
		if (caps.categories) {
			for (const [catId, catName] of Object.entries(caps.categories)) {
				const numId = parseInt(catId, 10);
				if (!isNaN(numId)) {
					categories.set(numId, catName);
				}
			}
		}
		if (caps.categorymappings) {
			for (const mapping of caps.categorymappings) {
				if (mapping.cat) {
					const numId = resolveCategoryId(mapping.cat);
					categories.set(numId, mapping.desc ?? mapping.cat);
				}
			}
		}

		return {
			search: modes['search']
				? buildSearchMode(modes['search'])
				: { available: true, supportedParams: ['q'] },
			movieSearch: modes['movie-search'] ? buildSearchMode(modes['movie-search']) : undefined,
			tvSearch: modes['tv-search'] ? buildSearchMode(modes['tv-search']) : undefined,
			musicSearch: modes['music-search'] ? buildSearchMode(modes['music-search']) : undefined,
			bookSearch: modes['book-search'] ? buildSearchMode(modes['book-search']) : undefined,
			categories,
			supportsPagination: false,
			supportsInfoHash: true,
			limitMax: 100,
			limitDefault: 100
		};
	}
}

/** Singleton instance */
let managerInstance: IndexerManager | null = null;

/** Get the singleton IndexerManager */
export async function getIndexerManager(): Promise<IndexerManager> {
	if (!managerInstance) {
		managerInstance = new IndexerManager();
		await managerInstance.initialize();
	}
	return managerInstance;
}

/** Reset the singleton (for testing) */
export function resetIndexerManager(): void {
	managerInstance = null;
}
